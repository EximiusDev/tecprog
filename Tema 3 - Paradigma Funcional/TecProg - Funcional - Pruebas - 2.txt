#lang racket/base
;(display "Hello, World!")

;se ejecuta de izquierda a derecha

"hola"
42
22/7
3.141592653
+
(+ 76 31)
'(a b c d)



;;;;;;;;;;;;;;;;;;;;;;;;


;cdr: accedo a la cola de la la lista, lo devuelve en forma de lista
; cdr: en la impropias devuelve el valor
;car: devuelve el 1er elemento de una lista, en forma de valor

;;;;;;;;;;;;;;;;;;;;;;;;

;definir un procedimiento:
  
(define cuadrado 
    (lambda (n) 
          (* n n)
                ) )
  
  
 (cuadrado 4)
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
 ;cons: no es concatenar, se le pasan 2 elementos, mete un elemento en una lista (se le pasa un elemento y una lista) 
    ;devuelve una lista con los elementos pasados (idealmente se le pasa un elemento y una lista)

; lista propia: (a b c) ---> tiene una lista vacia al final
; lista impropia: (a. b) ---> no tiene una lista vacia al final, solo tiene 2 valores


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(let ((x 2) (y 4))  (+ x y) )   ; cabecera: (x 2) (y 4) , cuerpo: (+ x y) 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Clase 2
;;;;;;;;;;;;;;;;;;;;;;;;;

; let () --> hace la asignacion a una variable de un valor
; let* () --> con let* puedo ver las asignaciones de la cabecera (asig anteriores) para las asignaciones posteriores
; letrec () --> let al que se le pueden asignar procedimientos recursivos

;  aunque let pueda parecer que introduce variables, en realidad introduce enlaces inmutables con ámbito léxico.

; Ejemplo;
; (+ (* 4 4) (* 4 4)) normal
; (let ((a (* 4 4))) (+ a a))  con let hace una expresion "a" para (* 4 4) --> a = 16

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; caar() es equivalente a hacer car(car())
; cadr() es equivalente a hacer car(cdr())


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Los procedimientos terminan con '?', ejemplo: (if (null? () ))

; eqv --> devuelve #t si son equivalentes
; equal --> devuelve #t si son equivalentes


; cond --> es como el switch de c++


;;;;;;;

; funcional --> calculo lambda [corazon de funcional]
;	    --> recursividad [pulmones de funcional]



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Vectores:

; #(a b c) ; -> vector de elementos a, b y c

; (vector 'a 'b 'c) ; => #(a b c)


; no se puede usar secuencia en funcional (pierde la esenciaG), entonces uso el let:
